# -*- coding: utf-8 -*-
"""FK

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nkhIIVTPRIWf6fRvscltbtXUuIYgFkZ6

**getting forward kinatic and inverse kinatic by getting DOF and DH parameter**
"""

9#getting input DOF and DH parameter
from matplotlib.pyplot import axis
import numpy as np
import pandas as pd

DOF = int(input("Enter degree of fredom DOF: "))
dict={0:'a',1:'alph',2:'d',3:'theta'}
DH  = np.zeros( (DOF, 4) )


for i in range(DOF):
  for j in range(4):
    DH[i][j]=int(input("Enter DH parameter for joint " +str(i) +" parameter "+dict[j]+' :'))


1#display DOF and DH parameter
def disply_DH_parameter():
  print('degree of fredom DOF: '+str(DOF))
  for i in range(DOF):
    for j in range(4):
      print("DH parameter for joint " +str(i) +" parameter "+dict[j]+': '+str(DH[i][j]))

#disply_DH_parameter()

import math
#0:a , 1:alpha , 2:d , 3:theta
def get_FK(DOF):
  A=np.array( [[[ math.floor(math.cos(math.radians(DH[i][3]))) , -math.floor((math.sin(math.radians(DH[i][3]))))*math.floor((math.cos(math.radians(DH[i][1])))) , math.floor((math.sin(math.radians(DH[i][3]))))*math.floor((math.sin(math.radians(DH[i][1])))) , (DH[i][0])*math.floor((math.cos(math.radians(DH[i][3])))) ] ,
                                              [math.floor(math.sin(math.radians(DH[i][3]))) , (math.floor(math.cos(math.radians(DH[i][3]))))*(math.floor(math.cos(math.radians(DH[i][1])))) , -(math.floor(math.cos(math.radians(DH[i][3]))))*math.floor(math.sin(math.radians(DH[i][1]))) , (DH[i][0])*math.floor((math.sin(math.radians(DH[i][3]))))] , 
                                              [ 0 , math.floor(math.sin(math.radians(DH[i][1]))) , math.floor(math.cos(math.radians(DH[i][1]))) , DH[i][2] ] , [0,0,0,1 ] ] for i in range(DOF)])
  return A

A=np.zeros((DOF,4,4))
A=get_FK(DOF)
A

#getting A matrix for each joint
d = {}
B=np.zeros((4,4))
for i in range(DOF):
  for j in range(4):
    for k in range(4):
      B[j][k]=A[i][j][k]
  d[f'A{i+1}'] = B


#getting A matrix for forward_kinematics

def get_final_FK():
  B=np.zeros((4,4))
  C=[[1,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,0,1]]
  for j in range(4):
    for k in range(4):
      C[j][k]=A[0][j][k]
#c=A0
  for i in range(1,DOF):
   for j in range(4):
    for k in range(4):
      B[j][k]=A[i][j][k]
   C=np.dot(C,B)
  return C

print(get_final_FK())

matrix = get_final_FK();
# getting position 
def get_pos():
 x = matrix[0][3]
 y = matrix[1][3]
 z = matrix[2][3]
 return x,y,z

# getting orientaion
def get_orientation():
 s= matrix[2][1]
 c= matrix[2][2]
 if (s==0 and c==0):
   psi = 0
 elif(s==1 and c==0):
   psi = 90
 else:
   psi = math.degrees(math.atan(s/c))

 s= matrix[1][0]
 c= matrix[0][0]
 if (s==0 and c==0):
   phai = 0
 elif(s==1 and c==0):
   phai = 90
 else:
   phai = math.degrees(math.atan(s/c))

 s= -matrix[2][0]
 c= math.sqrt(1-(matrix[2][0])**2)
 if (s==0 and c==0):
   theta = 0
 elif(s==1 and c==0):
   theta = 90
 else:
   theta = math.degrees(math.atan(s/c))
 return phai,theta,psi

x,y,z = get_pos()
phai,theta,psi = get_orientation()
# print("x: "+str(x)+" y: "+str(y)+' z: '+str(z))
# print("phai: "+str(phai)+" theta: "+str(theta)+' psi: '+str(psi))





##########################################################################################################
d2 = {}
for i in d:
  if int(i[-1])==1:
    continue

  if int(i[-1])==len(d):
    break


  if len(d2)==0:
   A12 = np.dot( d['A1'] ,d[i] )
   d2['A12']=A12

  else:
    mid_A = np.dot(d2[list(d2.keys())[-1]] , d[i])
    d2[list(d2.keys())[-1]+i[-1]] = mid_A

# print(d)
# print(d2)



pos = {}
Z_vectors = {}
for i in range(DOF+1):
  if i==0:
    O0 = np.zeros((3,1))
    Z0 = np.array(np.mat('0;0;1'))
    pos['O0']=O0
    Z_vectors['Z0']=Z0
  elif i==1:
    O1 = d['A1'][:3,3:4]
    Z1 = d['A1'][:3,2:3]
    pos['O1']=O1
    Z_vectors['Z1']=Z1
  elif i == DOF:
    amr = get_final_FK()[:3,3:4]
    pos[f'O{i}'] = amr  
  else:
    for j in d2:
      if int(j[-1])==i:
        amr = d2[j][:3,3:4]
        abd = d2[j][:3,2:3]
        pos[f'O{i}']=amr
        Z_vectors[f'Z{i}'] = abd


print(Z_vectors)

        
q=1  # prismatic or rotation

J_V =np.zeros((3,DOF))
J_W = np.zeros((3,DOF))

if q ==0 :
  for i in range(DOF+1):
    if i ==0:
      continue
    v = Z_vectors[f'Z{i-1}']
    J_V[:,(i-1):i] = v
    w = np.zeros((3,1))
    J_W[:,(i-1):i] = w

  J = np.concatenate((J_V,J_W), axis=0)  

print(J_V)
print(J_W)



print(J)



if q ==1:
  for i in range(DOF+1):
    if i ==0:
      continue
    diff_O = pos[f'O{DOF}'] - pos[f'O{i-1}']  
    v =np.cross(Z_vectors[f'Z{i-1}'] ,diff_O)
    J_V[:,(i-1):i] = v
    w = Z_vectors[f'Z{i-1}']
    J_W[:,(i-1):i] = w

  J = np.concatenate((J_V,J_W), axis=0)
      